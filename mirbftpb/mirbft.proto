/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

syntax = "proto3";

package mirbftpb;

// To re-generate, run:
//   protoc --go_out=. mirbft.proto
// or simply run go generate

message Msg {
    oneof type {
        Preprepare preprepare = 1;
        Prepare prepare = 2;
        Commit commit = 3;
        Forward forward = 4;
        Checkpoint checkpoint = 5;
        Suspect suspect = 6;
        EpochChange epoch_change = 7;
        NewEpoch new_epoch = 8;
        NewEpochEcho new_epoch_echo = 9;
        NewEpochReady new_epoch_ready = 10;
    }
}

message Preprepare {
    uint64 seq_no = 1;
    uint64 epoch = 2;
    uint64 bucket = 3;
    repeated bytes batch = 4;
}

message Prepare {
    uint64 seq_no = 1;
    uint64 epoch = 2;
    uint64 bucket = 3;
    bytes digest = 4;
}

message Commit {
    uint64 seq_no = 1;
    uint64 epoch = 2;
    uint64 bucket = 3;
    bytes digest = 4;
}

message Checkpoint {
    uint64 seq_no = 1;
    bytes value = 2;
}

message Forward {
    uint64 epoch = 1;
    uint64 bucket = 2;
    bytes data = 3;
}

message Suspect {
    uint64 epoch = 1;
}

// EpochChange messages are used to implement the classical PBFT view-change
// protocol, (very) slightly modified to adapt to Mir.  The assorted sets
// are encoded as repeated fields, rather than as maps for ease of serialization
// and particularly for computing a digest to attest to.  If any set contains
// a duplicated entry, the message may be discarded as byzantine.
message EpochChange {
    // attestation should be a signature covering the remainder of the fields
    // in the message.  additional information may optionally be encoded in the
    // attestation.
    bytes attestation = 1;

    uint64 new_epoch = 2;

    // c_set contains the entries for the C-set as defined by the classical
    // PBFT view-change protocol.
    repeated Checkpoint checkpoints = 3;

    message SetEntry {
        uint64 bucket = 1;
        uint64 epoch = 2;
        uint64 seq_no = 3;
        bytes digest = 4;
    }

    // p_set contains the entries for the P-set as defined by the classical
    // PBFT view-change protocol.  
    repeated SetEntry p_set = 4;

    // q_set contains the entries for the Q-set as defined by the classical
    // PBFT view-change protocol.
    repeated SetEntry q_set = 5;
}

message EpochConfig {
    // number of this new epoch
    uint64 number = 1;

    Checkpoint starting_checkpoint = 2;

    repeated uint64 leaders = 3;

    message Bucket {
         // digests is indexed by sequence number offset by the
         // starting_checkpoint seq_no. An empty digest corresponds
         // to a null request.
         repeated bytes digests = 1;
    }

    // final_preprepares finalizes the last checkpoint window or windows
    // which some correct replica preprepared a sequence in.  Notably
    // the bucket configuration is derived from the last active epoch.
    // By active epoch, we mean any epoch for which some correct replica
    // prepared a request.
    repeated Bucket final_preprepares = 4;
}

// NewEpoch is akin to the NewView message in classical PBFT and follows the same
// semantics.  Optionally, for graceful epoch change, the epoch_changes field may
// be empty.  In the event that the previous epoch does not complete gracefully,
// the graceful NewEpoch is ignored.  Unlike in classical PBFT, we employ a classical
// Bracha reliable broadcast on embedded config.  A replica should respond to a NewEpoch
// message with a NewEpochEcho (assuming that the NewEpoch message is validly constructed).
message NewEpoch {
    EpochConfig config = 1;

    // epoch_changes must contains at least 2f+1 EpochChange messages from
    // replicas in the network.  If two EpochChanges originated from the same
    // replica, then the NewEpoch message is invalid.
    repeated EpochChange epoch_changes = 2;
}

// NewEpochReady is for the second round of the classical Bracha reliable broadcast.  Note,
// that the message embeds only the config.  This is because the config is derived from
// the epoch_changes, and a correct replica will only echo the request if the config is validly
// constructed.  Since the echo phase only proceeds to ready if 2f+1 echos occur, some (actually, f+1)
// correct replicas must have validated the new config according to the epoch_changes.
message NewEpochEcho {
    EpochConfig config = 1;
}

// NewEpochReady is for the final round fo the classical Bracha reliable broadcast.
message NewEpochReady {
    EpochConfig config = 1;
}
